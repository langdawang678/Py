
# 不建议用进程继承的方式,创建比较麻烦,一般用进程池
# 进程池里的进程,都有各自的资源.
"""
当需要创建的子进程数量过多的时候，我们可以利用进程池来创建.

初始化Pool的时候，可以指定一个最大进程数.
当前新的请求提交到Pool中时，如果池中还没有满，那么就会创建一个新的进程用来执行该请求，
但是如果池中的进程数已经达到最大值，那么该请求就会等待，直到池中有进程结束，才会用之前的进程来执行新的任务

Pool常用的方法
    apply_async(func,args=(),kwds={},callback=None,error_callback=None)：
        使用非阻塞的方式调用func(并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程)
    close() : 关闭进程池
    terminate()：不管子进程是否结束，立即终止
    join() ：主进程阻塞，等待子进程结束，必须在close或terminate之后使用
"""
# 接[c26_页面布局xxxx]
from multiprocessing import pool
import os
import time

a = 0


def work():
    print(f"任务执行{a}", os.getpid())

    time.sleep(0.5)  # 不加的话一个进程全部执行完了


if __name__ == '__main__':
    p = pool.Pool(3)  # 创建进程池,3个进程

    # 创建10个任务
    for i in range(10):
        p.apply_async(work)

    p.close()  # 关闭进程池
    p.join()  # 主进程等待进程池中的所有进程都执行结束后,再往下执行.

'''只有3个进程在工作
任务执行0 14051
任务执行0 14052
任务执行0 14053
任务执行0 14051
任务执行0 14052
任务执行0 14053
任务执行0 14051
任务执行0 14052
任务执行0 14053
任务执行0 14051
'''